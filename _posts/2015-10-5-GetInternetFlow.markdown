---
layout: post
title: 通过IPHelper API获取系统上传/下载流量
categories:
- delphi笔记
---

通过IPHelper API获取系统上传/下载流量，delphi实现

微软提供了`iphlpapi.dll`动态链接库，用于获取网络相关的信息，可惜并没有找到现成封装好的，搜索了相关资料后解决问题，附上源码

``` delphi
unit InternetFlowUtils;(*  获取系统网络流量单元  Unit owner: BccSafe  blog: http://www.bccsafe.com/*)interfaceuses  Winapi.Windows, System.SysUtils;const  ANY_SIZE = 1;  MAX_INTERFACE_NAME_LEN = 256;  MAXLEN_PHYSADDR = 8;  MAXLEN_IFDESCR = 256;type  PTMibIfRow = ^TMibIfRow;  TMibIfRow = record    wszName: array [1 .. MAX_INTERFACE_NAME_LEN] of WCHAR;    dwIndex: DWORD;    dwType: DWORD;    dwMTU: DWORD;    dwSpeed: DWORD;    dwPhysAddrLen: DWORD;    bPhysAddr: array [1 .. MAXLEN_PHYSADDR] of byte;    dwAdminStatus: DWORD;    dwOperStatus: DWORD;    dwLastChange: DWORD;    dwInOctets: DWORD;    dwInUcastPkts: DWORD;    dwInNUCastPkts: DWORD;    dwInDiscards: DWORD;    dwInErrors: DWORD;    dwInUnknownProtos: DWORD;    dwOutOctets: DWORD;    dwOutUCastPkts: DWORD;    dwOutNUCastPkts: DWORD;    dwOutDiscards: DWORD;    dwOutErrors: DWORD;    dwOutQLen: DWORD;    dwDescrLen: DWORD;    bDescr: array [1 .. MAXLEN_IFDESCR] of AnsiChar;  end;  TIfRows = array of TMibIfRow;  PTMibIfTable = ^TMIBIfTable;  TMIBIfTable = record    dwNumEntries: DWORD;    Table: array [0 .. ANY_SIZE - 1] of TMibIfRow;  end;  TNetFlowDataType = (nfdt_Aver, nfdt_All);  // nfdt_Aver  一秒内的流量(平均值)  // nfdt_All 距离上次获取数据到现在的流量  TInternetFlow = record  private    FLastInOctets, FLastOutOctets, FLastTime: Int64;    FIsInit: Boolean;    FIpHlpModule: THandle;    FGetIfTable: function(pIfTable: PTMibIfTable; pdwSize: PULONG;      bOrder: Boolean): DWORD; stdCall;    function LoadIpHlp: Boolean;    procedure GetInOutOctets(var aInOct, aOutOct: Int64);    function IpHlpIfTable(var IfTot: integer; var IfRows: TIfRows): integer;  public    class function Create: TInternetFlow; static;    procedure Init;    procedure Close;    procedure CurrentData(var InOctets, OutOctets: Int64;      const NetFlowDataType: TNetFlowDataType = nfdt_Aver);  end;const  IpHlpDLL = 'IPHLPAPI.DLL';var  InternetFlow: TInternetFlow;implementation{ TInternetFlow }class function TInternetFlow.Create: TInternetFlow;begin  Result.FLastTime := -1;  Result.FLastInOctets := -1;  Result.FLastOutOctets := -1;  Result.FIsInit := false;end;procedure TInternetFlow.Close;begin  if FIpHlpModule <> 0 then    FreeLibrary(FIpHlpModule);end;function TInternetFlow.LoadIpHlp: Boolean;begin  Result := True;  if FIpHlpModule <> 0 then    Exit;  FIpHlpModule := LoadLibrary(IpHlpDLL);  if FIpHlpModule = 0 then  begin    Result := false;    Exit;  end;  FGetIfTable := GetProcAddress(FIpHlpModule, 'GetIfTable');end;function TInternetFlow.IpHlpIfTable(var IfTot: integer;  var IfRows: TIfRows): integer;var  i, TableSize: integer;  pBuf, pNext: PAnsiChar;begin  Result := ERROR_NOT_SUPPORTED;  if NOT LoadIpHlp then    Exit;  SetLength(IfRows, 0);  IfTot := 0;  TableSize := 0;  Result := FGetIfTable(Nil, @TableSize, false);  if Result <> ERROR_INSUFFICIENT_BUFFER then    Exit;  GetMem(pBuf, TableSize);  try    FillChar(pBuf^, TableSize, #0);    Result := FGetIfTable(PTMibIfTable(pBuf), @TableSize, false);    if Result <> NO_ERROR then      Exit;    IfTot := PTMibIfTable(pBuf)^.dwNumEntries;    if IfTot = 0 then      Exit;    SetLength(IfRows, IfTot);    pNext := pBuf + SizeOf(IfTot);    for i := 0 to Pred(IfTot) do    begin      IfRows[i] := PTMibIfRow(pNext)^;      inc(pNext, SizeOf(TMibIfRow));    end;  finally    FreeMem(pBuf);  end;end;procedure TInternetFlow.CurrentData(var InOctets, OutOctets: Int64;  const NetFlowDataType: TNetFlowDataType = nfdt_Aver);var  CurTime: Int64;begin  CurTime := GetTickCount;  GetInOutOctets(InOctets, OutOctets);  InOctets := InOctets div 1024;  OutOctets := OutOctets div 1024;  if FLastTime <> -1 then  begin    if NetFlowDataType = TNetFlowDataType.nfdt_Aver then    begin      InOctets := Round(InOctets / (CurTime - FLastTime) * 1000);      OutOctets := Round(OutOctets / (CurTime - FLastTime) * 1000);    end;  end;  FLastTime := CurTime;end;procedure TInternetFlow.GetInOutOctets(var aInOct, aOutOct: Int64);var  InOct, OutOct: Int64;  procedure _GetInOutOctets(var InOct, OutOct: Int64);  var    IfRows: TIfRows;    Error, i: integer;    NumEntries: integer;  begin    SetLength(IfRows, 0);    Error := IpHlpIfTable(NumEntries, IfRows);    if (Error = 0) and (NumEntries <> 0) then    begin      for i := 0 to Pred(NumEntries) do      begin        with IfRows[i] do        begin          InOct := dwInOctets;          OutOct := dwOutOctets;          if (dwInOctets <> 0) or (dwOutOctets <> 0) then            BREAK;        end;      end;    end;    SetLength(IfRows, 0);  end;begin  LoadIpHlp;  _GetInOutOctets(InOct, OutOct);  if (FLastInOctets = -1) or (FLastOutOctets = -1) then  begin    aInOct := 0;    aOutOct := 0;  end  else  begin    aInOct := InOct - FLastInOctets;    aOutOct := OutOct - FLastOutOctets;  end;  FLastInOctets := InOct;  FLastOutOctets := OutOct;end;procedure TInternetFlow.Init;var  InOctets, OutOctets: Int64;begin  if Not FIsInit then  begin    CurrentData(InOctets, OutOctets);    FIsInit := True;  end;end;initializationInternetFlow.Init;finalizationInternetFlow.Close;end.
``` 

调用方法如下

```delphi
procedure TForm1.Timer1Timer(Sender: TObject);var  InOctets, OutOctets: Int64;begin  InternetFlow.CurrentData(InOctets, OutOctets);  Memo1.Lines.Add(inttostr(InOctets) + '  ' + inttostr(OutOctets));end;
```

